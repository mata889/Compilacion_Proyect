package main;

import java.io.*;
import java_cup.runtime.*;
import java.util.*;

parser code
{:
    public static Nodo arbol;
    public static int token=0;
    public static int parNum=0;
    
    public static int SintacticError =0;

    public String tokenes_id(int id){
        switch(id){
            case 0: return "EOF";
            case 1: return "error";
            case 2: return "VERDAD";
            case 3: return "NUMERITO";
            case 4: return "LETRA";
            case 5: return "WORD";
            case 6: return "PUNTOC";
            case 7: return "PARENTESISA";
            case 8: return "PARENTESISC";
            case 9: return "ABRIRC";
            case 10: return "CERRARC";
            case 11: return "ASSIGNMENT";
            case 12: return "BRACKETA";
            case 13: return "BRACKETC";
            case 14: return "COMMA";
            case 15: return "OPER";
            case 16: return "OPEA_SUM";
            case 17: return "OPEA_MULT";
            case 18: return "BOOL";
            case 19: return "FOR";
            case 20: return "WLE";
            case 21: return "IF";
            case 22: return "EIF";
            case 23: return "ELSE";
            case 24: return "BLOCK";
            case 25: return "END";
            case 26: return "NUM";
            case 27: return "LETTER";
            case 28: return "FUNC";
            case 29: return "START";
            case 30: return "FLECHA";
            case 31: return "VAR";
            case 32: return "NOT";
            case 33: return "IN";
            case 34: return "PUNTO";
            case 35: return "CASE";
            case 36: return "DEFAULT";
            case 37: return "REPLY";
            case 38: return "ID";
            case 39: return "ARRAY";
            case 40: return "NEW";
            case 41: return "THROW";
            case 42: return "THROWDOWN";
            case 43: return "CATCH";
            case 44: return "CADENA";
            default: return "Nothing";
        }
    }

         /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
        System.out.println("Error Sintáctico en la Columna " + (s.left) +
        " linear "+s.right+ ". No se esperaba este componente: " +s.value+".");
        
        SintacticError++;

        List expected =expected_token_ids();
        if(expected.size()!=0){
            int id;
            System.out.print("TOKEN ESPERADO..");
            for(int i=0;i<expected.size();i++){
                id = (int) expected.get(i);
                    if (i == expected.size() - 1) {
                        System.out.println(tokenes_id(id));
                    } else {
                        System.out.println(tokenes_id(id) + " | ");
                    }
            }
        }
    } 

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la columna " + 
        (s.left)+ " linear "+s.right+". Componente " + s.value + 
        " no reconocido.");
        System.out.println("Sintaxis mal escrito,irrecuperable"); 
    }  
    
:}




//lexemas
terminal  VERDAD, NUMERITO, LETRA, WORD, CADENA;


//palabras reservadas y Operadores

terminal PUNTOC, PARENTESISA, PARENTESISC, ABRIRC, CERRARC , ASSIGNMENT, BRACKETA, BRACKETC, COMMA;
terminal OPER, OPEA_SUM, OPEA_MULT, BOOL,  FOR, WLE, IF, EIF, ELSE ,BLOCK, END;
terminal NUM, LETTER, FUNC, START ,FLECHA,  VAR ,  NOT;
terminal IN, PUNTO, CASE,DEFAULT, REPLY, ID;
terminal ARRAY,NEW;
terminal THROW,THROWDOWN,CATCH;

//not terminales
non terminal Program;
non terminal ifState;
non terminal else_n;
non terminal elseif;
non terminal expression;
non terminal valores;
non terminal type;
non terminal body;
non terminal parametrosf;
non terminal parametrof;

non terminal parametros;
non terminal parametro;
//non terminal declara;
non terminal declara_array;
non terminal declara_simple;
non terminal declara_assig;
non terminal assig;

non terminal eif;
non terminal proposition;
non terminal asigna;
non terminal CicloFor;
non terminal funciones;
non terminal expression_simple;
non terminal termino;
non terminal signo;
non terminal factor;
//non terminal factor_for;
non terminal list_expression;
non terminal block_switch;
non terminal cases;
//recursiva funciones
non terminal bodyf;
non terminal propositionf;
non terminal devolverFunc;

non terminal vacio;
non terminal print;
non terminal catch;
non terminal bracket_valores;
non terminal list_valores;
non terminal arrayData;
non terminal llamadaFunc;

start with Program;

//program
Program ::= START  FLECHA BRACKETA body:b BRACKETC
{:
    Nodo start = new Nodo("Start",token);
    parser.token ++;

    start.addHijo((Nodo)b);
 
    

    parser.arbol = start;
    RESULT = start;
:};

//declara ::= VAR type ID ASSIGNMENT  valores  PUNTOC;

declara_simple::= VAR:v type:t ID:ide PUNTOC
{:
        // Declaro el nodo declaración de variables
        Nodo decl = new Nodo("declaracion de variable",  parser.token);
        parser.token++;
        // Asigno var
        Nodo variable=new Nodo(v.toString(),parser.token);
        parser.token++;
        decl.addHijo(variable);
        parser.token++;
        // Asigno el tipo
        decl.addHijo((Nodo)t);
        // Asigno el id
        Nodo id=new Nodo("id",parser.token);
        parser.token++;
        id.addHijo(ide.toString(),parser.token);
        decl.addHijo(id);
        parser.token++;
        RESULT = decl;
:};

declara_assig ::=  VAR:v type:t ID:ide ASSIGNMENT valores:va PUNTOC
{:
        Nodo decl = new Nodo("declaracion y asignacion",  parser.token);
        parser.token++;
        // Asigno var
        Nodo variable=new Nodo(v.toString(),parser.token);
        parser.token++;
        decl.addHijo(variable);
        parser.token++;
        // Asigno el tipo
        decl.addHijo((Nodo)t);
        // Asigno el id
        Nodo id=new Nodo("id",parser.token);
        parser.token++;
        id.addHijo(new Nodo(ide.toString(),parser.token));
        decl.addHijo(id);
        parser.token++;
        // Asigno el valor
        Nodo val=new Nodo("valor",parser.token);
        parser.token++;
        val.addHijo((Nodo)va);
        decl.addHijo(val);

        RESULT = decl;
:}
    |  VAR:v type:t ID:ide ASSIGNMENT ID:ide2 PUNTOC
{:
        Nodo decl = new Nodo("declaracion y asignacion",  parser.token);
        parser.token++;
        // Asigno var
        Nodo variable=new Nodo(v.toString(),parser.token);
        parser.token++;
        decl.addHijo(variable);
        parser.token++;
        // Asigno el tipo
        decl.addHijo((Nodo)t);
        // Asigno el id
        Nodo id=new Nodo("id",parser.token);
        parser.token++;
        id.addHijo(new Nodo(ide.toString(),parser.token));
        decl.addHijo(id);
        parser.token++;
        // Asigno el valor
        Nodo id2=new Nodo("id",parser.token);
        parser.token++;
        id2.addHijo(new Nodo(ide2.toString(),parser.token));
        decl.addHijo(id2);
        parser.token++;

        RESULT = decl;
:};

assig ::= ID:ide ASSIGNMENT valores:v PUNTOC
{:
    Nodo decl = new Nodo("asignacion",  parser.token);
        parser.token++;
        // Asigno el id
        Nodo id=new Nodo("id",parser.token);
        parser.token++;
        id.addHijo(new Nodo(ide.toString(),parser.token));
        decl.addHijo(id);
        parser.token++;
        // Asigno el valor
        Nodo val=new Nodo("valor",parser.token);
        parser.token++;
        val.addHijo((Nodo)v);
        decl.addHijo(val);
        RESULT = decl;
:} 
    |   ID:ide ASSIGNMENT ID:ide2 PUNTOC
{:
    Nodo decl = new Nodo("asignacion",  parser.token);
        parser.token++;
        // Asigno el id
        Nodo id=new Nodo("id",parser.token);
        parser.token++;
        id.addHijo(new Nodo(ide.toString(),parser.token));
        decl.addHijo(id);
        parser.token++;
        // Asigno el valor
        Nodo id2=new Nodo("id",parser.token);
        parser.token++;
        id2.addHijo(new Nodo(ide2.toString(),parser.token));
        decl.addHijo(id2);
        parser.token++;
        RESULT = decl;
:};


//bodyf= REPLY PARENTESISA parametro:p2 PARENTESISC BRACKETC
funciones::= FUNC type:t ID:ide PARENTESISA parametrosf:p PARENTESISC BRACKETA bodyf:b BRACKETC
{:
    Nodo node= new Nodo("declaración de funcion",parser.token);
    parser.token++;

    Nodo funciones=new Nodo("función",parser.token);
    parser.token++;
    node.addHijo(funciones);

    node.addHijo((Nodo)t);

    Nodo id=new Nodo("id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id);
    parser.token++;

    Nodo parametros = new Nodo("parametros",parser.token);
    parser.token++;
    parametros.addHijitos( ((Nodo)p).getHijos() );

    node.addHijo(parametros);
    node.addHijo((Nodo)b);

    RESULT= node;
:}
    |   FUNC type:t ID:ide PARENTESISA PARENTESISC BRACKETA bodyf:b BRACKETC
{:
    Nodo node= new Nodo("Funciones",parser.token);
    parser.token++;

    Nodo funciones=new Nodo("funcion",parser.token);
    parser.token++;
    node.addHijo(funciones);

    node.addHijo((Nodo)t);

    Nodo id=new Nodo("id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id);
    parser.token++;
    
    Nodo vacio = new Nodo("Vacio",parser.token);
    parser.token++;

    Nodo parametros = new Nodo("parametros",parser.token);
    parser.token++;
    parametros.addHijo(vacio);
    
    node.addHijo(parametros);

    node.addHijo((Nodo)b);

    RESULT= node;
:}
    | error funciones:f
{:
    Nodo fun = new Nodo("funcion",parser.token);
    parser.token++;

    fun.addHijo("Error",parser.token);

    if(f!=null){
        fun.addHijitos(((Nodo)f).getHijos());
    }

     RESULT = fun;
:};

CicloFor::= FOR PARENTESISA ID:ide IN NUM:n PUNTO PUNTO PUNTO NUM:n1 PARENTESISC FLECHA ABRIRC body:b CERRARC
{:
        Nodo ciclo = new Nodo("declaración ciclo for",parser.token);
        parser.token++;

        Nodo ID=new Nodo("id",parser.token);
        parser.token++;
        ID.addHijo(ide.toString(),parser.token);
        
        ciclo.addHijo(ID);
        parser.token++;
 
        Nodo num1=new Nodo("num",parser.token);
        parser.token++;
        num1.addHijo(n.toString(),parser.token);
        parser.token++;
        ciclo.addHijo(num1);

        Nodo num2=new Nodo("num",parser.token);
        parser.token++;
        num2.addHijo(n1.toString(),parser.token);
        parser.token++;
        ciclo.addHijo(num2);

        ciclo.addHijo((Nodo)b);

        RESULT= ciclo;
:};

//body
body::= proposition:p body:b  {:
        Nodo bodyn = new Nodo("body",  parser.token);
        parser.token++;
        bodyn.addHijo((Nodo) p);
        
        if(b!=null){
            bodyn.addHijitos(((Nodo)b).getHijos());
        }

        RESULT = bodyn;
                
:} 
|funciones:f body:b 
{:
    Nodo funciones=new Nodo("Funciones",parser.token);
    parser.token++;

    funciones.addHijo((Nodo)f);

    if(b!=null){
        funciones.addHijitos(((Nodo)b).getHijos());
    }

    RESULT= funciones;
:}    
|{:
    Nodo node=new Nodo("Vacio",parser.token);
    parser.token++;
    RESULT=node;
:}
;



//body 
bodyf::= propositionf:p bodyf:b  {:
        Nodo bodyn = new Nodo("body",  parser.token);
        parser.token++;

        bodyn.addHijo((Nodo) p);
        
        if(b!=null){
            bodyn.addHijitos(((Nodo)b).getHijos());
        }

        RESULT = bodyn;
                
:}
    | error bodyf:b   
{:
    Nodo bodyn = new Nodo("body",  parser.token);
    parser.token++;
    bodyn.addHijo("Error",parser.token);
    parser.token++;
    if(b!=null){
            bodyn.addHijitos(((Nodo)b).getHijos());
        }
    RESULT=bodyn;
:}
|{:
    
:}; 


//propositionF
propositionf::= WLE expression:e FLECHA ABRIRC body:b CERRARC
{:
    Nodo node = new Nodo("declaración ciclo while",parser.token);
    parser.token++;

    Nodo whil=new Nodo("while",parser.token);
    parser.token++;
    node.addHijo(whil);

    node.addHijo((Nodo)e);

    node.addHijo((Nodo)b);

    RESULT= node;

:}
    | declara_simple:d
{:
    RESULT = (Nodo)d;
:}
    | declara_assig:da
{:
    RESULT = (Nodo)da;
:}
    | assig:a
{:
    RESULT = (Nodo)a;
:}
    | CicloFor:cf
{:
    RESULT = (Nodo)cf;
:}
    | llamadaFunc:lf PUNTOC
{:
    RESULT=lf;
:}
    | ifState:ife
{:
    RESULT = ife;
:}
    |   block_switch:b
{:
    RESULT=b;
:}
    |   print:p
{:
    RESULT=p;
:}
    |   catch:c
{:
    RESULT=c;
:}
    |   declara_array:da 
{:
    RESULT = da;
:}  
    |   REPLY PARENTESISA devolverFunc:df PARENTESISC 
{:
    Nodo node = new Nodo("reply",parser.token);
    parser.token++;
    node.addHijo((Nodo)df);
    RESULT=node;
:};

//devuelve la funcion
devolverFunc::= valores:v
{:
    RESULT=v;
:}
    | llamadaFunc:lf
{:
    RESULT=lf;
:}
    | ID:ide
{:
    Nodo ID = new Nodo("id",parser.token);
    parser.token++;

    ID.addHijo(ide.toString(),parser.token);
    
    parser.token++;

    RESULT = ID;
:};

// Parámetros a funciones
parametrosf::= parametrof:p COMMA parametrosf:ps
{:
    Nodo node=new Nodo("Parametros",parser.token);
    parser.token++;
    node.addHijo((Nodo)p);
    node.addHijitos(((Nodo)ps).getHijos());
    RESULT=node;
:}
    |  parametrof:p
{:
    Nodo node=new Nodo("Parametros",parser.token);
    parser.token++;
    node.addHijo((Nodo)p);
    RESULT=node;
:}
    | error
{:
    Nodo error=new Nodo("error parametro",parser.token);
    parser.token++;
    RESULT=error;
:};
parametrof ::= type:t ID:id
{:
    Nodo param = new Nodo("Parametro",parser.token);
    parser.token++;
    param.addHijo((Nodo)t);
    Nodo nom = new Nodo(""+id,parser.token);
    parser.token++;
    param.addHijo(nom);
    RESULT = param;
:};

//parametros para los llamados a funciones
parametros::= parametro:p COMMA parametros:ps
{:
    Nodo node=new Nodo("Parametros",parser.token);
    parser.token++;
    node.addHijo((Nodo)p);
    node.addHijitos(((Nodo)ps).getHijos());
    RESULT=node;
:}
    |  parametro:p
{:
    Nodo node=new Nodo("Parametros",parser.token);
    parser.token++;
    node.addHijo((Nodo)p);
    RESULT=node;
:}
    | error
{:
    Nodo error=new Nodo("error parametro",parser.token);
    parser.token++;
    RESULT=error;
:};
parametro ::= ID:id
{:
    Nodo param = new Nodo("Parametro",parser.token);
    parser.token++;
    Nodo nom =new Nodo(""+id,parser.token);
    parser.token++;
    param.addHijo(nom);
    RESULT=param;
:};

//proposciones
proposition::= WLE expression:e FLECHA ABRIRC body:b CERRARC
{:
    Nodo node = new Nodo("declaración ciclo while",parser.token);
    parser.token++;

    Nodo whil=new Nodo("while",parser.token);
    parser.token++;
    node.addHijo(whil);

    node.addHijo((Nodo)e);

    node.addHijo((Nodo)b);

    RESULT= node;
:}
    | declara_simple:d
{:
    RESULT = (Nodo)d;
:}
    | declara_assig:da
{:
    RESULT = (Nodo)da;
:}
    | assig:a
{:
    RESULT = (Nodo)a;
:}
    |   CicloFor:cf
{:
    RESULT = (Nodo)cf;
:}
    |   llamadaFunc:lf PUNTOC
{:
        RESULT=lf;
:}
    |   ifState:ife
{:
    RESULT = ife;
:}
    |   block_switch:b
{:
    RESULT=b;
:}
    |   print:p
{:
    RESULT=p;
:}
    |   catch:c
{:
    RESULT=c;
:}
    |declara_array:da 
{:
    RESULT = da;
:}
    | error proposition:p
{:
    Nodo node = new Nodo("Error ",parser.token);
    parser.token++;

    if(p!=null){
        node.addHijitos(((Nodo)p).getHijos());
    }

    RESULT = node;
:};

//llamada de funciones
llamadaFunc ::= ID:ide PARENTESISA parametros:p PARENTESISC
{:
    Nodo node=new Nodo("llamada a funcion",parser.token);
    parser.token++;

    Nodo id=new Nodo("ID",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;

    node.addHijo((Nodo)p);

    RESULT = node;

:}
    | ID:ide PARENTESISA  PARENTESISC
{:
    Nodo node=new Nodo("llamada a funcion",parser.token);
    parser.token++;

    Nodo id=new Nodo("ID",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;

    Nodo p=new Nodo("Vacio",parser.token);
    parser.token++;

    node.addHijo((Nodo)p);

    RESULT = node;
:}
    | error
{:
    Nodo error=new Nodo("error llamada a funcion",parser.token);
    parser.token++;

    RESULT=error;
:};

//impresiones
print::= THROW PARENTESISA ID:ide PARENTESISC PUNTOC
{:
    Nodo node=new Nodo("throw",parser.token);
    parser.token++;

    Nodo id=new Nodo("id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;

    RESULT=node;
:}
    |   THROW PARENTESISA valores:v PARENTESISC PUNTOC
{:
    Nodo node=new Nodo("throw",parser.token);
    parser.token++;

    node.addHijo((Nodo)v);
 
    RESULT=node;
:}
    |   THROWDOWN PARENTESISA ID:ide PARENTESISC PUNTOC
{:
    Nodo node=new Nodo("throwdown",parser.token);
    parser.token++;

    Nodo id=new Nodo("id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;
 
    RESULT=node;
:}
    |   THROWDOWN PARENTESISA valores:v PARENTESISC PUNTOC
{:
    Nodo node=new Nodo("throwdown",parser.token);
    parser.token++;

    node.addHijo((Nodo)v);

    RESULT=node;
:};

//scanner     
catch::= CATCH PARENTESISA ID:ide PARENTESISC PUNTOC
{:
    Nodo node=new Nodo("catch",parser.token);
    parser.token++;

    Nodo id=new Nodo("id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;
 
    RESULT=node;
:};

//tipo
type::= VERDAD
{:
    
    Nodo node = new Nodo("booleano",  parser.token);
    parser.token++;
    RESULT = node;
    
:}
    | NUMERITO
{:
    Nodo node = new Nodo("entero",  parser.token);
    parser.token++;
    RESULT = node;
:}
    | LETRA
{:
    Nodo node = new Nodo("caracter",  parser.token);
    parser.token++;
    RESULT = node;
:}
    | WORD
{:
    Nodo node = new Nodo("string",  parser.token);
    parser.token++;
    RESULT = node;
:};

//array
declara_array::= VAR ID:ide ASSIGNMENT NEW ARRAY PARENTESISA NUM:n1 PARENTESISC  PUNTOC
{:

    Nodo node = new Nodo("declaración array",parser.token);
    parser.token++;

    Nodo array=new Nodo("array()",parser.token);
    parser.token++;
    node.addHijo(array); 

    Nodo id=new Nodo("id",parser.token);
    parser.token++;
    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;
 
    Nodo num2=new Nodo("indice",parser.token);
    parser.token++;
    num2.addHijo(n1.toString(),parser.token);
    parser.token++;
    node.addHijo(num2);

    RESULT = node;
:} 
| VAR ID:ide ASSIGNMENT NEW ARRAY PARENTESISA NUM:n1 PARENTESISC  bracket_valores:bv PUNTOC
{:
    Nodo node = new Nodo("declaración array",parser.token);
    parser.token++;

    Nodo id=new Nodo("id",parser.token);
    parser.token++;
    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;

    Nodo num2=new Nodo("indice",parser.token);
    parser.token++;
    num2.addHijo(n1.toString(),parser.token);
    parser.token++;
    node.addHijo(num2);

    
 
    node.addHijo((Nodo)bv);

    RESULT= node;
:}
;

bracket_valores::= BRACKETA list_valores:lv BRACKETC
{:
    RESULT=lv;
:};

list_valores::= arrayData:ad COMMA list_valores:lv
{:
    Nodo node=new Nodo("valores",parser.token);
    parser.token++;
    node.addHijo((Nodo)ad);

    if(lv!=null){
        node.addHijitos(((Nodo)lv).getHijos());
    }
    RESULT=node;
:}
| arrayData:ad
{:
    Nodo node=new Nodo("Valores",parser.token);
    parser.token++;
    node.addHijo((Nodo)ad);
    RESULT=node;
:}
| bracket_valores:b COMMA bracket_valores:b1
{:
    Nodo node=new Nodo("dos dimensiones",parser.token);
    parser.token++;

    node.addHijo((Nodo)b);
    node.addHijo((Nodo)b1);

    RESULT=node;
:};

arrayData::= valores:v
{:
    RESULT=v;
:};

//valores
valores::= NUM:n
{:
    Nodo node=new Nodo("num",parser.token);
    parser.token++;
    Nodo valor = new Nodo(""+n,parser.token);
    parser.token++;

    node.addHijo(valor);

    RESULT = node;
:}
    |   BOOL:b
{:
    Nodo node=new Nodo("bool",parser.token);
    parser.token++;
    Nodo valor = new Nodo(""+b,parser.token);
    parser.token++;
    
    node.addHijo(valor);

    RESULT = node;
:}
    |   LETTER:l
{:
    Nodo node=new Nodo("letter",parser.token);
    parser.token++;
    Nodo valor = new Nodo(""+l,parser.token);
    parser.token++;
    
    node.addHijo(valor);

    RESULT = node;
:} |   CADENA:c
{:
    String cadenita = c.toString().replace("\"","");
    Nodo node=new Nodo("string",parser.token);
    parser.token++;
    Nodo valor = new Nodo(cadenita,parser.token);
    parser.token++;
    
    node.addHijo(valor);

    RESULT = node;
:};

//if
ifState::= IF PARENTESISA expression:e PARENTESISC ABRIRC body:b CERRARC
{:
    Nodo node=new Nodo("declaración if",parser.token);
    parser.token++;
    Nodo ife= new Nodo("if",parser.token);
    parser.token++;
    node.addHijo(ife);
    node.addHijo((Nodo)e);
    if (b!=null) node.addHijo((Nodo)b);
    RESULT=node;
:}
| IF PARENTESISA expression:e PARENTESISC ABRIRC body:b CERRARC else_n:el
{:
    Nodo node = new Nodo("declaración if",parser.token);
    parser.token++;
    Nodo ife=new Nodo("if",parser.token);
    parser.token++;
    node.addHijo(ife);
    node.addHijo((Nodo)e);
    if (b!=null) node.addHijo((Nodo)b);
    node.addHijo((Nodo)el);
    RESULT=node;
:}
| IF PARENTESISA expression:e PARENTESISC ABRIRC body:b CERRARC elseif:el
{:
    Nodo node = new Nodo("declaración if",parser.token);
    parser.token++;
    Nodo ife=new Nodo("if",parser.token);
    parser.token++;
    node.addHijo(ife);
    node.addHijo((Nodo)e);
    if (b!=null) node.addHijo((Nodo)b);
    node.addHijo((Nodo)el);
    RESULT=node;
:};

else_n::= ELSE ABRIRC body:b CERRARC
{:
    Nodo node = new Nodo("else",parser.token);
    parser.token++;
    if (b!=null) node.addHijo((Nodo)b);
    RESULT=node;
:};

elseif::= ELSE ifState:i
{:
    Nodo node = new Nodo("else if",parser.token);
    parser.token++;
    node.addHijitos(((Nodo)i).getHijos());
    RESULT=node;
:};


//bloque switch
//siwthc sale null.point exception nose porque
block_switch::= BLOCK PARENTESISA ID:ide PARENTESISC FLECHA cases:c END
{:
    Nodo node=new Nodo("declaración bloque switch",parser.token);
    parser.token++;

    Nodo block=new Nodo("Block",parser.token);
    parser.token++;
    node.addHijo(block);
 
    Nodo id=new Nodo("id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    parser.token++;
    node.addHijo(id);
   
    node.addHijo((Nodo)c);

    Nodo end=new Nodo("end",parser.token);
    parser.token++;
    node.addHijo(end);

    RESULT = node;
:};
cases::= CASE ID:ide ABRIRC body:b CERRARC cases:c
{:
    
    Nodo node=new Nodo("case body",parser.token);
    parser.token++;

    Nodo cas=new Nodo("Case",parser.token);
    parser.token++;
    
    Nodo id=new Nodo("id",parser.token);
    parser.token++;
    cas.addHijo(ide.toString(),parser.token);
    parser.token++;
 
    cas.addHijo((Nodo)b);
 
    if(c!=null){
        node.addHijitos(((Nodo)c).getHijos());
    }
    
    node.addHijo(cas);

    RESULT = node;
:}
    |   CASE valores:v ABRIRC body:b CERRARC cases:c
{:
    
    Nodo node=new Nodo("Cases",parser.token);
    parser.token++;

    Nodo cas=new Nodo("Case",parser.token);
    parser.token++;
    node.addHijo(cas);

    node.addHijo((Nodo)v);
 
    node.addHijo((Nodo)b);
  
    if(c!=null){
        node.addHijitos(((Nodo)c).getHijos());
    }

    RESULT= node;
    
:}
    |   DEFAULT ABRIRC body:b CERRARC 
{:
    
    Nodo node=new Nodo("Cases",parser.token);
    parser.token++;
 
    node.addHijo((Nodo)b);
 
    RESULT=node;
    
:}
| error 
{:
    Nodo error=new Nodo("Erros-case",parser.token);
    parser.token++;

    RESULT=error;
:};

//expresiones
expression::= expression_simple:es
{:
    RESULT=es;
:}
    |   expression_simple:es OPER:op expression:ex
{:
    Nodo node =new Nodo("expresión simple",parser.token);
    parser.token++;
    node.addHijo((Nodo)es);

    node.addHijo(op.toString(),parser.token);
    parser.token++;

    if(ex!=null){
        node.addHijitos(((Nodo)ex).getHijos());
    }
    
    RESULT=node;
:}
    | error 
{:
    Nodo error=new Nodo("error expresión",parser.token);
    parser.token++;

    RESULT=error;
:};

expression_simple::= termino:t
{:  
    RESULT=t;
:}
    |   signo:s termino:t
{:
    RESULT=(Nodo)t;
:}
    |   expression_simple:exs OPEA_SUM:op termino:t
{:
    Nodo node=new Nodo("expresión simple",parser.token);
    parser.token++;

    if(exs!=null){
        node.addHijitos(((Nodo)exs).getHijos());
    }

    Nodo opea_sum=new Nodo("operador suma/resta",parser.token);
    parser.token++;
    opea_sum.addHijo(op.toString(),parser.token);
    parser.token++;
    node.addHijo(opea_sum);

    node.addHijo((Nodo)t);

    RESULT=node;
:};

termino::= factor:f
{:
    RESULT=f;
:}
    |   termino:t OPEA_MULT:op factor:f
{:
    Nodo node =new Nodo("termino",parser.token);
    parser.token++;
    if(t!=null){
        node.addHijitos(((Nodo)t).getHijos());
    }
    Nodo opea_mult=new Nodo("operador multiplicacion/division",parser.token);
    parser.token++;

    opea_mult.addHijo(op.toString(),parser.token++);
    parser.token++;

    node.addHijo(opea_mult);

    node.addHijo((Nodo)f);

    RESULT=node;

:};
//tener cuidado con el not
factor::= ID:ide
{:
    Nodo node=new Nodo("factor",parser.token);
    parser.token++;

    Nodo id=new Nodo("id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    parser.token++;
    node.addHijo(id);

    RESULT=node;
:}
    |   ID:ide PARENTESISA list_expression:list PARENTESISC
{:
    Nodo node=new Nodo("factor",parser.token);
    parser.token++;

    Nodo id=new Nodo("id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    parser.token++;
    node.addHijo(id);
    

    node.addHijo((Nodo)list);
   
    RESULT=node;
:}
    |   valores:v
{:
    RESULT=v;
:}
    |   PARENTESISA expression:e PARENTESISC
{:
    Nodo node=new Nodo("factor",parser.token);
    parser.token++;
    node.addHijo((Nodo)e);
    RESULT=node;
:}
    |   NOT:n factor:f
{:
    Nodo node=new Nodo("factor",parser.token);
    parser.token++;

    Nodo not=new Nodo("Not",parser.token);
    parser.token++;
    not.addHijo(n.toString(),parser.token);

    if(f!=null){
        node.addHijitos(((Nodo)f).getHijos());
    }

    RESULT=node;
:};

signo ::= OPEA_SUM:op
{:
    Nodo node= new Nodo("Signo",parser.token);
    parser.token++;

    Nodo opea_sum=new Nodo("Operacion Suma/Resta",parser.token);
    parser.token++;
    opea_sum.addHijo(op.toString(),parser.token);
    parser.token++;

    node.addHijo(opea_sum);

    RESULT=node;
:};

list_expression::= expression:e
{:
    Nodo node=new Nodo("Lista de Expresiones",parser.token);
    parser.token++;
    node.addHijo((Nodo)e);

    RESULT=e;
:} | list_expression:list COMMA expression:e
{:
    Nodo node=new Nodo("Lista de Expresiones",parser.token);
    parser.token++;

    if(list!=null){
        node.addHijitos(((Nodo)list).getHijos());
    }
    Nodo coma=new Nodo(",",parser.token);
    parser.token++;
    node.addHijo(coma);

    node.addHijo((Nodo)e);
    
    RESULT=node;
:};