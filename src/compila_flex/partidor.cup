package compila_flex;

import java.io.*;
import java_cup.runtime.*;
import java.util.*;

parser code
{:
    public static Nodo arbol;
    public static int token=0;
    public static int parNum=0;
    
         /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
       System.out.println("Error Sintáctico en la Columna " + (s.left) +
        " linear "+s.right+ ". No se esperaba este componente: " +s.value+".");
       System.out.println("Sintaxis malo malo malo");
    } 

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la columna " + 
        (s.left)+ " linear "+s.right+". Componente " + s.value + 
        " no reconocido.");
        System.out.println("Sintaxis MAL irrecuperable"); 
    }  
    
:}




//lexemas
terminal  VERDAD, NUMERITO, LETRA,WORD;


//palabras reservadas y Operadores

terminal PUNTOC, PARENTESISA, PARENTESISC, ABRIRC, CERRARC , ASSIGNMENT, BRACKETA, BRACKETC, COMMA;
terminal OPER, OPEA_SUM, OPEA_MULT, BOOL,  FOR, WLE, IF, EIF, ELSE ,BLOCK, END;
terminal NUM, LETTER, FUNC, START ,FLECHA,  VAR ,  NOT;
terminal IN, PUNTO, CASE,DEFAULT, REPLY, ID;
terminal ARRAY,NEW;
terminal THROW,THROWDOWN,CATCH;

//not terminales
non terminal Program;
non terminal ifState;
non terminal expression;
non terminal valores;
non terminal type;
non terminal body;
non terminal parametro;
//non terminal declara;
non terminal declara_puntoc;
non terminal declara_array;
non terminal declara_simple;
non terminal eif;
non terminal proposition;
non terminal asigna;
non terminal CicloFor;
non terminal funciones;
non terminal expression_simple;
non terminal termino;
non terminal signo;
non terminal factor;
//non terminal factor_for;
non terminal list_expression;
non terminal block_switch;
non terminal cases;
non terminal vacio;
non terminal print;
non terminal catch;

start with Program;

//program
Program ::= START  FLECHA BRACKETA body:b BRACKETC
{:
    Nodo start = new Nodo("Start",token);
    parser.token ++;
    
    Nodo flecha = new Nodo("Flecha",token);
    start.addHijo(flecha);
    parser.token ++;

    Nodo Braca = new Nodo("Braca",token);
    start.addHijo(Braca);
    parser.token ++;
    
    start.addHijo((Nodo)b);

    Nodo Bracc = new Nodo("Bracc",token);
    start.addHijo(Bracc);
    parser.token ++;
    
    

    parser.arbol = start;
    RESULT = start;
:};

//declara ::= VAR type ID ASSIGNMENT  valores  PUNTOC;

declara_simple::= VAR:v type:t ID:ide declara_puntoc:dc
{:
        Nodo decl = new Nodo("Declaracion Simple",  parser.token);
        parser.token++;

        Nodo variable=new Nodo("Variable",parser.token);
        parser.token++;

        variable.addHijo(v.toString(),parser.token);
        decl.addHijo(variable);
        parser.token++;

        decl.addHijo((Nodo)t);

        Nodo id=new Nodo("ID",parser.token);
        parser.token++;

        id.addHijo(ide.toString(),parser.token);
        decl.addHijo(id);
        parser.token++;

        decl.addHijo((Nodo)dc);

        RESULT = decl;
    
:}
;

funciones::= FUNC type:t ID:ide PARENTESISA parametro:p PARENTESISC BRACKETA body:b REPLY PARENTESISA parametro:p2 PARENTESISC BRACKETC
{:
    Nodo node= new Nodo("Funciones",parser.token);
    parser.token++;

    Nodo funciones=new Nodo("Funcion",parser.token);
    parser.token++;
    node.addHijo(funciones);

    node.addHijo((Nodo)t);

    Nodo id=new Nodo("ID",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id);
    parser.token++;

    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa);

    node.addHijo((Nodo)p);

    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);

    Nodo bracketa=new Nodo("[",parser.token);
    parser.token++;
    node.addHijo(bracketa);

    node.addHijo((Nodo)b);

    Nodo reply=new Nodo("Reply",parser.token);
    parser.token++;
    node.addHijo(reply);

    node.addHijo((Nodo)p2);

    RESULT= node;
:};

CicloFor::= FOR PARENTESISA ID:ide IN NUM:n PUNTO PUNTO PUNTO NUM:n1 PARENTESISC FLECHA ABRIRC body:b CERRARC
{:
        Nodo ciclo = new Nodo("CicloFor",parser.token);
        parser.token++;

        Nodo fore= new Nodo("For",parser.token);
        parser.token++;
        ciclo.addHijo(fore);
        
    /*
        Nodo parentesisa=new Nodo("(",parser.token);
        parser.token++;
        ciclo.addHijo(parentesisa);
        
*/
        Nodo ID=new Nodo("Id",parser.token);
        parser.token++;
        ID.addHijo(ide.toString(),parser.token);
        
        ciclo.addHijo(ID);
        parser.token++;

        Nodo in=new Nodo("in",parser.token);
        parser.token++;
        ciclo.addHijo(in);

        Nodo num1=new Nodo("num",parser.token);
        parser.token++;
        num1.addHijo(n.toString(),parser.token);
        parser.token++;
        ciclo.addHijo(num1);

        Nodo punto=new Nodo("...",parser.token);
        parser.token++;
        ciclo.addHijo(punto);
        
        Nodo num2=new Nodo("num",parser.token);
        parser.token++;
        num2.addHijo(n1.toString(),parser.token);
        parser.token++;
        ciclo.addHijo(num2);
/*
        Nodo parentesisc=new Nodo(")",parser.token);
        parser.token++;
        ciclo.addHijo(parentesisc);

        Nodo flecha=new Nodo("->",parser.token);
        parser.token++;
        ciclo.addHijo(flecha);

        Nodo abrirc=new Nodo("<",parser.token);
        parser.token++;
        ciclo.addHijo(abrirc);
*/
        ciclo.addHijo((Nodo)b);
/*
        Nodo cerrarc=new Nodo(">",parser.token);
        parser.token++;
        ciclo.addHijo(cerrarc);
*/
        RESULT= ciclo;
:};
//body
body::= proposition:p body:b  {:
        Nodo bodyn = new Nodo("body",  parser.token);
        parser.token++;
        bodyn.addHijo((Nodo) p);
        System.out.println("entro a  body");
        if(b!=null){
            bodyn.addHijitos(((Nodo)b).getHijos());
        }

        RESULT = bodyn;
                
:} 
|funciones:f body:b 
{:
    Nodo funciones=new Nodo("Funciones",parser.token);
    parser.token++;

    funciones.addHijo((Nodo)f);

    if(b!=null){
        funciones.addHijitos(((Nodo)b).getHijos());
    }

    RESULT= funciones;
:}    |{::}

;
//parametro
parametro::= type:t ID:id
{:
    Nodo node=new Nodo("Parametro",parser.token);
    parser.token++;

    node.addHijo((Nodo)t);

    Nodo ID = new Nodo("ID",parser.token);
    parser.token++;

    ID.addHijo(id.toString(),parser.token);
    node.addHijo(ID);
    parser.token++;

    RESULT=node;
:}
    | ID:id
{:
    Nodo node=new Nodo("Parametro",parser.token);
    parser.token++;

    Nodo ID = new Nodo("ID",parser.token);
    parser.token++;

    ID.addHijo(id.toString(),parser.token);
    node.addHijo(ID);
    parser.token++;

    RESULT=node;
:};
//proposciones
proposition::= WLE expression:e FLECHA ABRIRC proposition:p CERRARC
{:
    Nodo node = new Nodo("Proposicion",parser.token);
    parser.token++;

    Nodo whil=new Nodo("while",parser.token);
    parser.token++;
    node.addHijo(whil);

    node.addHijo((Nodo)e);

    node.addHijo((Nodo)p);

    RESULT= node;

:}
   
    |   declara_simple:d
{:
    
    Nodo node = new Nodo("Proposicion",parser.token);
    parser.token++;
    node.addHijo((Nodo)d);
    
    RESULT = node;
:}
    |   CicloFor:cf
{:
    Nodo node = new Nodo("CicloFor",parser.token);
    parser.token++;
    node.addHijo((Nodo)cf);

    RESULT = node;
:}
    |   ifState:ife
{:
    /*
    Nodo node = new Nodo("IF",parser.token);
    parser.token++;
    node.addHijo((Nodo)ife);
    */
    RESULT = ife;
:}
    |   ID:id ASSIGNMENT expression:e PUNTOC
{:

    Nodo node = new Nodo("Proposicion",parser.token);
    parser.token++;

    Nodo ID = new Nodo("ID",parser.token);
    parser.token++;

    ID.addHijo(id.toString(),parser.token);
    node.addHijo(ID);
    parser.token++;

    Nodo assing =new Nodo("=",parser.token);
    parser.token++;
    node.addHijo(assing);
    node.addHijo((Nodo)e);

    Nodo puntoc= new Nodo(";",parser.token);
    parser.token++;
    node.addHijo(puntoc);

    RESULT = node;
:}
    |   block_switch:b
{:
    RESULT=b;
:}
    |   print:p
{:
    RESULT=p;
:}
    |   catch:c
{:
    RESULT=c;
:};
//impresiones
print::= THROW PARENTESISA ID:ide PARENTESISC PUNTOC
{:
    Nodo node=new Nodo("Print",parser.token);
    parser.token++;

    Nodo thro=new Nodo("Throw",parser.token);
    parser.token++;
    node.addHijo(thro);

    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa);

    Nodo id=new Nodo("ID",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;

    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);

    Nodo puntoc=new Nodo(";",parser.token);
    parser.token++;
    node.addHijo(puntoc);

    RESULT=node;
:}
    |   THROW PARENTESISA valores:v PARENTESISC PUNTOC
{:
    Nodo node=new Nodo("Print",parser.token);
    parser.token++;

    Nodo thro=new Nodo("Throw",parser.token);
    parser.token++;
    node.addHijo(thro);

    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa);

    node.addHijo((Nodo)v);

    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);

    Nodo puntoc=new Nodo(";",parser.token);
    parser.token++;
    node.addHijo(puntoc);

    RESULT=node;
:}
    |   THROWDOWN PARENTESISA ID:ide PARENTESISC PUNTOC
{:
       Nodo node=new Nodo("Print",parser.token);
    parser.token++;

    Nodo thro=new Nodo("ThrowDOWN",parser.token);
    parser.token++;
    node.addHijo(thro);

    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa);

    Nodo id=new Nodo("ID",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;

    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);

    Nodo puntoc=new Nodo(";",parser.token);
    parser.token++;
    node.addHijo(puntoc);

    RESULT=node;
:}
    |   THROWDOWN PARENTESISA valores:v PARENTESISC PUNTOC
{:
    Nodo node=new Nodo("Print",parser.token);
    parser.token++;

    Nodo thro=new Nodo("ThrowDown",parser.token);
    parser.token++;
    node.addHijo(thro);

    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa);

    node.addHijo((Nodo)v);

    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);

    Nodo puntoc=new Nodo(";",parser.token);
    parser.token++;
    node.addHijo(puntoc);

    RESULT=node;
:};

//scanner     
catch::= CATCH PARENTESISA ID:ide COMMA ID:ide2 PARENTESISC PUNTOC
{:
    Nodo node=new Nodo("Empieza el catch",parser.token);
    parser.token++;

    Nodo catche=new Nodo("Catch",parser.token);
    parser.token++;
    node.addHijo(catche);

    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa); 

    Nodo id=new Nodo("ID",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;

    Nodo comma=new Nodo(",",parser.token);
    parser.token++;
    node.addHijo(comma); 

    Nodo id_2=new Nodo("ID",parser.token);
    parser.token++;

    id_2.addHijo(ide2.toString(),parser.token);
    node.addHijo(id_2); 
    parser.token++;

    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);

    Nodo puntoc=new Nodo(";",parser.token);
    parser.token++;
    node.addHijo(puntoc);

    RESULT=node;
:};

//tipo
type::= VERDAD
{:
    parser.token++;
    Nodo node = new Nodo("Verdad",  parser.token);
    RESULT = node;
    
:}
    | NUMERITO
{:
    parser.token++;
    Nodo node = new Nodo("Numero",  parser.token);
    RESULT = node;
:}
    | LETRA
{:
    parser.token++;
    Nodo node = new Nodo("Char",  parser.token);
    RESULT = node;
:}
    | WORD
{:
    parser.token++;
    Nodo node = new Nodo("String",  parser.token);
    RESULT = node;
:};

//declara puntoC
declara_puntoc::= PUNTOC
{:
    Nodo node =new Nodo("Declaracion Puntoc",parser.token);
    node.addHijo(";",parser.token);
    parser.token++;

    RESULT = node;
:}
    |   asigna:as
{:
    /*Nodo node =new Nodo("Asignacion",parser.token);
    node.addHijo((Nodo)as);
    parser.token++;*/

    RESULT = as;
:};

//asignacion
asigna::= ASSIGNMENT valores:v PUNTOC
{:
    Nodo node=new Nodo("asignacion",parser.token);
    parser.token++;

    Nodo assignment=new Nodo("=",parser.token);
    node.addHijo(assignment);
    parser.token++;

    node.addHijo((Nodo)v);

    Nodo puntoc=new Nodo(";",parser.token);
    node.addHijo(puntoc);
    parser.token++;

    RESULT= node;
:}
    |   ASSIGNMENT ID:ide PUNTOC
{:
    Nodo node=new Nodo("asignacion",parser.token);
    parser.token++;

    Nodo assignment=new Nodo("=",parser.token);
    node.addHijo(assignment);
    parser.token++;  

    Nodo id=new Nodo("ID",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    node.addHijo(id); 
    parser.token++;

    Nodo puntoc=new Nodo(";",parser.token);
    node.addHijo(puntoc);
    parser.token++;

    RESULT= node;
:}
    |   vacio PUNTOC
{:
    Nodo node=new Nodo("asignacion",parser.token);
    parser.token++;

    Nodo puntoc=new Nodo(";",parser.token);
    node.addHijo(puntoc);
    parser.token++;

    RESULT= node;
:};

//array
declara_array::= VAR ID ASSIGNMENT NEW ARRAY PARENTESISA NUM PARENTESISC BRACKETA type BRACKETC;

//valores
valores::= NUM:n
{:
    Nodo node=new Nodo("Valores",parser.token);
    parser.token++;
    node.addHijo(n.toString(),parser.token);
    parser.token++;

    RESULT = node;
:}
    |   BOOL:b
{:
    Nodo node=new Nodo("Valores",parser.token);
    parser.token++;
    node.addHijo(b.toString(),parser.token);
    parser.token++;

    RESULT = node;
:}
    |   LETTER:l
{:
    Nodo node=new Nodo("Valores",parser.token);
    parser.token++;
    node.addHijo(l.toString(),parser.token);
    parser.token++;

    RESULT = node;
:};

//if

ifState::= IF PARENTESISA expression:e PARENTESISC ABRIRC proposition:p CERRARC eif:ei
{:
    Nodo node=new Nodo("Empiezo IF",parser.token);
    parser.token++;

    Nodo ife=new Nodo("IF",parser.token);
    parser.token++;
    node.addHijo(ife);

    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa);

    node.addHijo((Nodo)e);

    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);

    Nodo abrirc=new Nodo("<",parser.token);
    parser.token++;
    node.addHijo(abrirc);

    node.addHijo((Nodo)p);

    Nodo cerrarc=new Nodo(">",parser.token);
    parser.token++;
    node.addHijo(cerrarc);

    node.addHijo((Nodo)ei);

    RESULT=node;
:};

eif::= EIF expression:e ABRIRC proposition:p CERRARC eif:eife
{:
    Nodo node=new Nodo("Else if",parser.token);
    parser.token++;

    Nodo ei=new Nodo("eif",parser.token);
    parser.token++;
    node.addHijo(ei);

    node.addHijo((Nodo)e);

    Nodo abrirc=new Nodo("<",parser.token);
    parser.token++;
    node.addHijo(abrirc);

    node.addHijo((Nodo)p);

    Nodo cerrarc=new Nodo(">",parser.token);
    parser.token++;
    node.addHijo(cerrarc);

    if(eife!=null){
        node.addHijitos(((Nodo)eife).getHijos());
    }

    RESULT= node;
:}
    |   ELSE ABRIRC proposition:p CERRARC
{:
    Nodo node=new Nodo("Else if",parser.token);
    parser.token++;

    Nodo ei=new Nodo("else",parser.token);
    parser.token++;
    node.addHijo(ei);

    Nodo abrirc=new Nodo("<",parser.token);
    parser.token++;
    node.addHijo(abrirc);

    node.addHijo((Nodo)p);

    Nodo cerrarc=new Nodo(">",parser.token);
    parser.token++;
    node.addHijo(cerrarc);

    RESULT=node;
:}
    |   {::};

//bloque switch
//siwthc sale null.point exception nose porque
block_switch::= BLOCK PARENTESISA ID:ide PARENTESISC FLECHA cases:c END
{:
   
    Nodo node=new Nodo("Bloque Switch",parser.token);
    parser.token++;

    Nodo block=new Nodo("Block",parser.token);
    parser.token++;
    node.addHijo(block);

    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa);

    Nodo id=new Nodo("Id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    parser.token++;
    node.addHijo(id);

    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);

    Nodo flecha=new Nodo("->",parser.token);
    parser.token++;
    node.addHijo(flecha);

    if(c!=null){
        node.addHijitos(((Nodo)c).getHijos());
    }

    Nodo end=new Nodo("end",parser.token);
    parser.token++;
    node.addHijo(end);

    RESULT = node;

:};

cases::= CASE ID:ide ABRIRC body:b CERRARC cases:c
{:
    Nodo node=new Nodo("Cases",parser.token);
    parser.token++;

    Nodo cas=new Nodo("Case",parser.token);
    parser.token++;
    node.addHijo(cas);

    Nodo id=new Nodo("Id",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    parser.token++;
    node.addHijo(id);

    Nodo abrirc=new Nodo("<",parser.token);
    parser.token++;
    node.addHijo(abrirc);

    node.addHijo((Nodo)b);

    Nodo cerrac=new Nodo(">",parser.token);
    parser.token++;
    node.addHijo(cerrac);

    if(c!=null){
        node.addHijitos(((Nodo)c).getHijos());
    }

    RESULT = node;

:}
    |   CASE valores:v ABRIRC body:b CERRARC cases:c
{:
    Nodo node=new Nodo("Cases",parser.token);
    parser.token++;

    Nodo cas=new Nodo("Case",parser.token);
    parser.token++;
    node.addHijo(cas);

    node.addHijo((Nodo)v);

    Nodo abrirc=new Nodo("<",parser.token);
    parser.token++;
    node.addHijo(abrirc);

    node.addHijo((Nodo)b);

    Nodo cerrac=new Nodo(">",parser.token);
    parser.token++;
    node.addHijo(cerrac);

    if(c!=null){
        node.addHijitos(((Nodo)c).getHijos());
    }

    RESULT= node;
:}
    |   DEFAULT ABRIRC body:b CERRARC 
{:
    Nodo node=new Nodo("Cases",parser.token);
    parser.token++;

    Nodo defaulte=new Nodo("Default",parser.token);
    parser.token++;
    node.addHijo(defaulte);

    Nodo abrirc=new Nodo("<",parser.token);
    parser.token++;
    node.addHijo(abrirc);

    node.addHijo((Nodo)b);

    Nodo cerrac=new Nodo(">",parser.token);
    parser.token++;
    node.addHijo(cerrac);

    RESULT=node;

:};
//expresiones
expression::= expression_simple:es
{:
    /*Nodo node =new Nodo("expression simple",parser.token);
    parser.token++;
    node.addHijo((Nodo)es);
    */
    RESULT=es;
:}
    |   expression_simple:es OPER expression:ex
{:
    Nodo node =new Nodo("expression simple",parser.token);
    parser.token++;
    node.addHijo((Nodo)es);

    Nodo oper=new Nodo("Operador Relacional",parser.token);
    parser.token++;
    node.addHijo(oper);

    if(ex!=null){
        node.addHijitos(((Nodo)es).getHijos());
    }
    
    RESULT=node;
:};

expression_simple::= termino:t
{:
    /*
    Nodo node=new Nodo("Expresion simpel",parser.token);
    parser.token++;

    node.addHijo((Nodo)t);
    */
    RESULT=t;
:}
    |   signo:s termino:t
{:
    Nodo node=new Nodo("Expresion simple",parser.token);
    parser.token++;

    node.addHijo((Nodo)s);
    node.addHijo((Nodo)t);

    RESULT=node;
:}
    |   expression_simple:exs OPEA_SUM:op termino:t
{:
    Nodo node=new Nodo("Expresion simple",parser.token);
    parser.token++;

    if(exs!=null){
        node.addHijitos(((Nodo)exs).getHijos());
    }

    Nodo opea_sum=new Nodo("Operacion de Suma/Resta",parser.token);
    parser.token++;
    opea_sum.addHijo(op.toString(),parser.token);
    parser.token++;
    node.addHijo(opea_sum);

    node.addHijo((Nodo)t);

    RESULT=node;
:};

termino::= factor:f
{:
    RESULT=f;
:}
    |   termino:t OPEA_MULT:op factor:f
{:
    Nodo node =new Nodo("Termino",parser.token);
    parser.token++;

    if(t!=null){
        node.addHijitos(((Nodo)t).getHijos());
    }
    Nodo opea_mult=new Nodo("Operador de Multiplicacion/Division",parser.token);
    parser.token++;

    opea_mult.addHijo(op.toString(),parser.token++);
    parser.token++;

    node.addHijo(opea_mult);

    node.addHijo((Nodo)f);

    RESULT=node;

:};
//tener cuidado con el not
factor::= ID:ide
{:
    Nodo node=new Nodo("factor",parser.token);
    parser.token++;

    Nodo id=new Nodo("ID",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    parser.token++;
    node.addHijo(id);

    RESULT=node;
:}
    |   ID:ide PARENTESISA list_expression:list PARENTESISC
{:
    Nodo node=new Nodo("factor",parser.token);
    parser.token++;

    Nodo id=new Nodo("ID",parser.token);
    parser.token++;

    id.addHijo(ide.toString(),parser.token);
    parser.token++;
    node.addHijo(id);
    /*
    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa);
    */

    node.addHijo((Nodo)list);
    /*
    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);
    */
    RESULT=node;
:}
    |   valores:v
{:
    /*Nodo node=new Nodo("factor",parser.token);
    parser.token++;
    node.addHijo((Nodo)v);*/
    RESULT=v;
:}
    |   PARENTESISA expression:e PARENTESISC
{:
    Nodo node=new Nodo("factor",parser.token);
    parser.token++;
    /*
    Nodo parentesisa=new Nodo("(",parser.token);
    parser.token++;
    node.addHijo(parentesisa);
    */
    node.addHijo((Nodo)e);
    /*
    Nodo parentesisc=new Nodo(")",parser.token);
    parser.token++;
    node.addHijo(parentesisc);
    */
    RESULT=node;
:}
    |   NOT:n factor:f
{:
    Nodo node=new Nodo("factor",parser.token);
    parser.token++;

    Nodo not=new Nodo("Not",parser.token);
    parser.token++;
    not.addHijo(n.toString(),parser.token);

    if(f!=null){
        node.addHijitos(((Nodo)f).getHijos());
    }

    RESULT=node;
:};

/*factor_for ::= ID
	| NUM
	| signo NUM;
*/
signo ::= OPEA_SUM:op
{:
    Nodo node= new Nodo("Signo",parser.token);
    parser.token++;

    Nodo opea_sum=new Nodo("Operacion Suma/Resta",parser.token);
    parser.token++;
    opea_sum.addHijo(op.toString(),parser.token);
    parser.token++;

    node.addHijo(opea_sum);

    RESULT=node;
:};

list_expression::= expression:e
{:
    Nodo node=new Nodo("Expresiones",parser.token);
    parser.token++;
    node.addHijo((Nodo)e);

    RESULT=e;
:} | list_expression:list COMMA expression:e
{:
    Nodo node=new Nodo("Expresiones",parser.token);
    parser.token++;

    if(list!=null){
        node.addHijitos(((Nodo)list).getHijos());
    }
    Nodo coma=new Nodo(",",parser.token);
    parser.token++;
    node.addHijo(coma);

    node.addHijo((Nodo)e);
    
    RESULT=node;
:};