package compila_flex;

import java.io.*;
import java_cup.runtime.*;
import java.util.*;

parser code
{:
    public static Nodo arbol;
    public static int token=0;
    public static int parNum=0;
    
         /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
       System.out.println("Error Sintáctico en la Columna " + (s.left) +
        " linear "+s.right+ ". No se esperaba este componente: " +s.value+".");
       System.out.println("Sintaxis malo malo malo");
    } 

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la columna " + 
        (s.left)+ " linear "+s.right+". Componente " + s.value + 
        " no reconocido.");
        System.out.println("Sintaxis MAL irrecuperable"); 
    }  
    
:}




//lexemas
terminal  VERDAD, NUMERITO, LETRA,WORD;


//palabras reservadas y Operadores

terminal PUNTOC, PARENTESISA, PARENTESISC, ABRIRC, CERRARC , ASSIGNMENT, BRACKETA, BRACKETC, COMMA;
terminal OPER, OPEA_SUM, OPEA_MULT, BOOL,  FOR, WLE, IF, EIF, ELSE ,BLOCK, END;
terminal NUM, LETTER, FUNC, START ,FLECHA,  VAR ,  NOT;
terminal IN, PUNTO, CASE,DEFAULT, REPLY, ID;
terminal ARRAY,NEW;
terminal THROW,THROWDOWN,CATCH;

//not terminales
non terminal Program;
non terminal ifState;
non terminal expression;
non terminal valores;
non terminal type;
non terminal body;
non terminal parametro;
//non terminal declara;
non terminal declara_puntoc;
non terminal declara_array;
non terminal declara_simple;
non terminal eif;
non terminal proposition;
non terminal asigna;
non terminal CicloFor;
non terminal funciones;
non terminal expression_simple;
non terminal termino;
non terminal signo;
non terminal factor;
//non terminal factor_for;
non terminal list_expression;
non terminal block_switch;
non terminal cases;
non terminal vacio;
non terminal print;
non terminal catch;

start with Program;

//program
Program ::= START  FLECHA BRACKETA body:b BRACKETC
{:
    System.out.println("entro el payaso");
    Nodo start = new Nodo("Start",token);
    parser.token ++;
    
    Nodo flecha = new Nodo("Flecha",token);
    start.addHijo(flecha);
    parser.token ++;

    Nodo Braca = new Nodo("Braca",token);
    start.addHijo(Braca);
    parser.token ++;
    
    start.addHijo((Nodo)b);

    Nodo Bracc = new Nodo("Bracc",token);
    start.addHijo(Bracc);
    parser.token ++;
    
    

    parser.arbol = start;
    RESULT = start;
:};

//declara ::= VAR type ID ASSIGNMENT  valores  PUNTOC;

declara_simple::= VAR:v type:t ID:ide declara_puntoc:dc
{:
        System.out.println("Salio de decl simple");
        Nodo decl = new Nodo("Declaracion Simple",  parser.token);
        parser.token++;

        Nodo variable=new Nodo("Variable",parser.token);
        parser.token++;

        variable.addHijo(v.toString(),parser.token);
        decl.addHijo(variable);
        parser.token++;

        decl.addHijo((Nodo)t);

        Nodo id=new Nodo("ID",parser.token);
        parser.token++;

        id.addHijo(ide.toString(),parser.token);
        decl.addHijo(id);
        parser.token++;

        decl.addHijo((Nodo)dc);

        RESULT = decl;
    
:}
;

funciones::= FUNC type ID PARENTESISA parametro PARENTESISC BRACKETA body REPLY PARENTESISA parametro PARENTESISC BRACKETC;

CicloFor::= FOR PARENTESISA ID IN NUM PUNTO PUNTO PUNTO NUM PARENTESISC FLECHA ABRIRC body CERRARC;
//body
body::= proposition:p body:b  {:
        Nodo bodyn = new Nodo("body",  parser.token);
        parser.token++;
        bodyn.addHijo((Nodo) p);
        System.out.println("entro a  body");
        if(b!=null){
            bodyn.addHijitos(((Nodo)b).getHijos());
        }

        RESULT = bodyn;
                
:} 
|funciones:f body:b 
    |{::}

;
//parametro
parametro::= type ID
    | ID;
//proposciones
proposition::= WLE expression FLECHA ABRIRC proposition CERRARC
   
    |   declara_simple:d
{:
    
    /*Nodo node = new Nodo("Proposicion",parser.token);
    parser.token++;
    node.addHijo((Nodo)d);
    */
    RESULT = d;
:}
    |   CicloFor
    |   ifState
    |   ID:id ASSIGNMENT expression:e PUNTOC
{:

    Nodo node = new Nodo("Proposicion",parser.token);
    parser.token++;

    Nodo ID = new Nodo("ID",parser.token);
    parser.token++;

    ID.addHijo(id.toString(),parser.token);
    node.addHijo(ID);
    parser.token++;

    Nodo assing =new Nodo("=",parser.token);
    parser.token++;
    node.addHijo(assing);
    node.addHijo((Nodo)e);

    Nodo puntoc= new Nodo(";",parser.token);
    parser.token++;
    node.addHijo(puntoc);

    RESULT = node;
:}
    |   block_switch
    |   print
    |   catch;
//impresiones
print::= THROW PARENTESISA ID PARENTESISC PUNTOC
    |   THROW PARENTESISA valores PARENTESISC PUNTOC
    |   THROWDOWN PARENTESISA ID PARENTESISC PUNTOC
    |   THROWDOWN PARENTESISA valores PARENTESISC PUNTOC;

//scanner     
catch::= CATCH PARENTESISA ID COMMA ID PARENTESISC PUNTOC;

//tipo
type::= VERDAD
{:
    parser.token++;
    Nodo node = new Nodo("Verdad",  parser.token);
    RESULT = node;
    
:}
    | NUMERITO
{:
    parser.token++;
    Nodo node = new Nodo("Numero",  parser.token);
    RESULT = node;
:}
    | LETRA
{:
    parser.token++;
    Nodo node = new Nodo("Char",  parser.token);
    RESULT = node;
:}
    | WORD
{:
    parser.token++;
    Nodo node = new Nodo("String",  parser.token);
    RESULT = node;
:};

//declara puntoC
declara_puntoc::= PUNTOC
{:
    Nodo node =new Nodo("Declaracion Puntoc",parser.token);
    node.addHijo(";",parser.token);
    parser.token++;

    RESULT = node;
:}
    |   asigna:as;

//asignacion
asigna::= ASSIGNMENT valores PUNTOC
    |   ASSIGNMENT ID PUNTOC
    |   vacio PUNTOC;

//array
declara_array::= VAR ID ASSIGNMENT NEW ARRAY PARENTESISA NUM PARENTESISC BRACKETA type BRACKETC;

//valores
valores::= NUM
    |   BOOL
    |   LETTER;

//if

ifState::= IF PARENTESISA expression PARENTESISC ABRIRC proposition CERRARC eif;

eif::= EIF expression ABRIRC proposition CERRARC eif
    |   ELSE ABRIRC proposition CERRARC
    |   {::};

//bloque switch
block_switch::= BLOCK PARENTESISA ID PARENTESISC FLECHA cases END;

cases::= CASE ID ABRIRC body CERRARC cases
    |   CASE valores ABRIRC body CERRARC cases
    |   DEFAULT ABRIRC body CERRARC ;
//expresiones
expression::= expression_simple
    |   expression_simple OPER expression;

expression_simple::= termino
    |   signo termino
    |   expression_simple OPEA_SUM termino;

termino::= factor
    |   termino OPEA_MULT factor;
//tener cuidado con el not
factor::= ID
    |   ID PARENTESISA list_expression PARENTESISC
    |   valores
    |   PARENTESISA expression PARENTESISC
    |   NOT factor;

/*factor_for ::= ID
	| NUM
	| signo NUM;
*/
signo ::= OPEA_SUM;

list_expression::= expression | list_expression COMMA expression;